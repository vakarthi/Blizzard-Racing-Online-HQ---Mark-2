
import { DataContextType } from '../contexts/AppContext';

// --- Helper Functions ---
const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
};

// --- Knowledge Base ---
const KNOWLEDGE_BASE: Record<string, string> = {
    'aerodynamics': 'Aerodynamics is the study of how gases interact with moving bodies. In F1, it determines downforce and drag.',
    'downforce': 'Downforce is the vertical force generated by aerodynamic surfaces (wings, floor) pushing the car into the track for better grip.',
    'drag': 'Drag is the aerodynamic resistance that opposes the forward motion of the car. Minimizing it increases top speed.',
    'cfd': 'Computational Fluid Dynamics. The use of applied mathematics and physics to solve problems that involve fluid flows.',
    'boundary layer': 'The thin layer of fluid in the immediate vicinity of a bounding surface where the effects of viscosity are significant.',
    'reynolds number': 'A dimensionless quantity used to help predict flow patterns in different fluid flow situations.',
    'lift-to-drag': 'A ratio that indicates the efficiency of an airfoil. In racing, we often call this Efficiency.',
    'ground effect': 'The increased lift (downforce) and decreased aerodynamic drag that an aircraft\'s wings generate when they are close to a fixed surface.',
};

// --- Responder Interface and List ---
interface Responder {
    regex: RegExp;
    handler: (match: RegExpMatchArray, data: DataContextType, isEggheadMode: boolean) => string;
}

const RESPONDERS: Responder[] = [
    // --- Conversational ---
    {
        regex: /^(hello|hi|hey|greetings)/i,
        handler: () => "Hello! How can I assist with the Blizzard Racing data today?"
    },
    {
        regex: /^(thanks|thank you)/i,
        handler: () => "You're welcome! Is there anything else I can help you with?"
    },

    // --- Knowledge Base ---
    {
        regex: /(what is|what's|define|explain|who is) (aerodynamics|downforce|chassis|drag|lift|cfd|boundary layer|reynolds number|ground effect)/i,
        handler: (match) => {
            const term = match[2].toLowerCase().replace(/\s/g, '');
            // Simple mapping for multi-word keys
            if(term.includes('reynolds')) return KNOWLEDGE_BASE['reynolds number'];
            if(term.includes('boundary')) return KNOWLEDGE_BASE['boundary layer'];
            if(term.includes('ground')) return KNOWLEDGE_BASE['ground effect'];
            
            return KNOWLEDGE_BASE[term] || `I don't have a definition for "${term}" in the archives.`;
        }
    },

    // --- Protocol Responder ---
    {
        regex: /(?:protocol for|run protocol|what is the procedure for|show protocol) (.*)/i,
        handler: (match, data) => {
            const protocolKeyword = match[1].trim().toLowerCase();
            const protocol = data.protocols.find(p => p.title.toLowerCase().includes(protocolKeyword));

            if (protocol) {
                const steps = protocol.steps.map((step, index) => `${index + 1}. ${step}`).join('\n');
                return `Here is the protocol for "${protocol.title}":\n\n**${protocol.description}**\n\n${steps}`;
            }

            return `I could not find a protocol related to "${protocolKeyword}".`;
        }
    },

    // --- Data Analysis ---
    {
        regex: /best (aero|design|car)/i,
        handler: (_, data) => {
            if (!data.aeroResults || data.aeroResults.length === 0) {
                return "No simulation data found. Please run simulations first.";
            }
            
            const bestResult = data.aeroResults.reduce((best, current) => 
                current.liftToDragRatio > best.liftToDragRatio ? current : best
            );

            return `The best performing design is "${bestResult.parameters.carName}". It has a lift-to-drag ratio of ${bestResult.liftToDragRatio.toFixed(2)}.`;
        }
    },
    {
        regex: /(most active member|who posts the most)/i,
        handler: (_, data) => {
            const postCounts: Record<string, number> = {};
            data.discussionThreads.forEach(thread => {
                thread.posts.forEach(post => {
                    postCounts[post.authorId] = (postCounts[post.authorId] || 0) + 1;
                });
            });
            
            if (Object.keys(postCounts).length === 0) return "No communications detected.";

            const mostActiveAuthorId = Object.keys(postCounts).reduce((a, b) => postCounts[a] > postCounts[b] ? a : b);
            const mostActiveMember = data.getTeamMember(mostActiveAuthorId);

            if (!mostActiveMember) return "Identity unknown.";
            
            return `The most active member is ${mostActiveMember.name} with ${postCounts[mostActiveAuthorId]} posts.`;
        }
    },
];

export const queryLocalAI = (query: string, data: DataContextType, isEggheadMode: boolean = false): string => {
    const q = query.toLowerCase().trim().replace(/[?.,!]/g, '');

    for (const responder of RESPONDERS) {
        const match = q.match(responder.regex);
        if (match) {
            return responder.handler(match, data, isEggheadMode);
        }
    }

    return "I'm sorry, I can't answer that. You can ask me about protocols, define engineering terms, or ask about team data.";
};
